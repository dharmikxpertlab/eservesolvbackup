import { EventEmitter, Component, Renderer2, ViewContainerRef, Input, Output, ViewChild, NgModule } from '@angular/core';
import SignaturePad from 'signature_pad';
import { Overlay, OverlayModule } from '@angular/cdk/overlay';
import { TemplatePortal } from '@angular/cdk/portal';
import { CommonModule } from '@angular/common';

class NgxSignaturePadComponent {
    constructor(renderer2, overlay, viewContainerRef) {
        this.renderer2 = renderer2;
        this.overlay = overlay;
        this.viewContainerRef = viewContainerRef;
        // #endregion
        this.signDataHistory = [];
        this._isEmpty = true;
        this.isFullScreen = false;
        this.options = {};
        this.beginSign = new EventEmitter();
        this.endSign = new EventEmitter();
    }
    get activePad() {
        return this.isFullScreen ? this.bigPad : this.smallPad;
    }
    fullScreen() {
        this.portal = new TemplatePortal(this.fullScreenTpl, this.viewContainerRef);
        this.overlayRef = this.overlay.create({
            positionStrategy: this.overlay.position().global(),
            scrollStrategy: this.overlay.scrollStrategies.block(),
            height: '100%',
            width: '100%'
        });
        this.overlayRef.attach(this.portal);
        this.initBigPad();
        // #region Copy miniScreen's content to fullScreen
        const { width: miniScreenWidth, height: miniScreenHeight } = this.options;
        const ctx = this.bigCanvas.getContext('2d');
        ctx.save();
        ctx.translate(this.fullScreenWidth, 0);
        ctx.rotate((90 * Math.PI) / 180);
        ctx.drawImage(this.smallCanvas, 0, 0, miniScreenWidth, miniScreenHeight, 0, 0, this.fullScreenHeight, this.fullScreenWidth);
        ctx.restore();
        // #endregion
        this.isFullScreen = true;
    }
    miniScreen() {
        this.smallPad.clear();
        // #region Copy fullScreen's content to miniScreen
        const { width: miniScreenWidth, height: miniScreenHeight } = this.options;
        const widthScale = miniScreenWidth / this.fullScreenHeight;
        const heightScale = miniScreenHeight / this.fullScreenWidth;
        const ctx = this.smallCanvas.getContext('2d');
        ctx.save();
        ctx.translate(0, miniScreenHeight);
        ctx.rotate((-90 * Math.PI) / 180);
        ctx.drawImage(this.bigCanvas, 0, 0, this.fullScreenWidth, this.fullScreenHeight, 0, 0, this.fullScreenWidth * widthScale, this.fullScreenHeight * heightScale);
        ctx.restore();
        // #endregion
        this.overlayRef.dispose();
        this.bigCanvas = null;
        this.bigPad = null;
        this.isFullScreen = false;
    }
    /** Returns signature image as an array of point groups */
    toData() {
        return this.activePad.toData();
    }
    /** Draws signature image from an array of point groups */
    fromData(pointGroups) {
        this.activePad.fromData(pointGroups);
    }
    toDataURL(type) {
        switch (type) {
            case 'image/jpeg':
                return this.activePad.toDataURL('image/jpeg');
            case 'image/svg+xml':
                return this.activePad.toDataURL('image/svg+xml');
            default:
                return this.activePad.toDataURL();
        }
    }
    revert() {
        this.signDataHistory.pop();
        this.fromData(this.signDataHistory);
        if (this.signDataHistory.length === 0) {
            this.setEmpty();
        }
    }
    // Clears the canvas
    clear() {
        this.setEmpty();
        this.signDataHistory = [];
        this.activePad.clear();
    }
    /** Return true if canvas is empty, otherwise return false */
    isEmpty() {
        return this._isEmpty;
    }
    /** Set canvas's state as dirty */
    setDirty() {
        this._isEmpty = false;
    }
    /** Set canvas's state as empty */
    setEmpty() {
        this._isEmpty = true;
    }
    getContext() {
        return this.isFullScreen ? this.bigCanvas.getContext('2d') : this.smallCanvas.getContext('2d');
    }
    initBigPad() {
        this.bigCanvas = document.querySelector('#nsp-big');
        const fullScreenOptions = JSON.parse(JSON.stringify(this.options));
        // Calculate the fullScreen pad's size
        this.fullScreenWidth = document.documentElement.clientWidth;
        const { width: miniScreenWidth, height: miniScreenHeight } = this.options;
        this.fullScreenHeight = (this.fullScreenWidth * miniScreenWidth) / miniScreenHeight;
        // Calculate section size
        const viewHeight = document.documentElement.clientHeight;
        const space = viewHeight - this.fullScreenHeight;
        this.sectionHeight = space / 2;
        // Init pad
        fullScreenOptions.width = this.fullScreenWidth;
        fullScreenOptions.height = this.fullScreenHeight;
        const { css } = fullScreenOptions;
        this.bigCanvas.width = this.fullScreenWidth;
        this.bigCanvas.height = this.fullScreenHeight;
        for (const key in css) {
            if (Object.prototype.hasOwnProperty.call(css, key)) {
                const value = css[key];
                this.renderer2.setStyle(this.bigCanvas, key, value);
            }
        }
        this.bigPad = new SignaturePad(this.bigCanvas, fullScreenOptions);
        this.bigPad.onBegin = this._onBegin.bind(this);
        this.bigPad.onEnd = this._onEnd.bind(this);
    }
    initSmallPad() {
        this.smallCanvas = document.querySelector('#nsp-small');
        const { width, height, css } = this.options;
        this.options.width = width ? width : 300;
        this.options.height = height ? height : 150;
        this.smallCanvas.width = this.options.width;
        this.smallCanvas.height = this.options.height;
        for (const key in css) {
            if (Object.prototype.hasOwnProperty.call(css, key)) {
                const value = css[key];
                this.renderer2.setStyle(this.smallCanvas, key, value);
            }
        }
        this.smallPad = new SignaturePad(this.smallCanvas, this.options);
        this.smallPad.onBegin = this._onBegin.bind(this);
        this.smallPad.onEnd = this._onEnd.bind(this);
    }
    _onBegin() {
        this.setDirty(); // When user draws, set state as dirty
        this.beginSign.emit();
    }
    _onEnd() {
        this.signDataHistory = this.toData();
        this.endSign.emit();
    }
    setPadAttribute(key, value) {
        if (this.bigPad) {
            this.bigPad[key] = value;
        }
        this.smallPad[key] = value;
    }
    ngOnInit() {
        this.initSmallPad();
    }
    ngOnChanges(changes) {
        if (changes.options.firstChange) {
            return;
        }
        const { dotSize, minWidth, maxWidth, throttle, minDistance, backgroundColor, penColor, velocityFilterWeight, width, height, css } = changes.options.currentValue;
        if (dotSize) {
            this.setPadAttribute('dotSize', dotSize);
        }
        if (minWidth) {
            this.setPadAttribute('minWidth', minWidth);
        }
        if (maxWidth) {
            this.setPadAttribute('maxWidth', maxWidth);
        }
        if (throttle) {
            this.setPadAttribute('throttle', throttle);
        }
        if (minDistance) {
            this.setPadAttribute('minDistance', minDistance);
        }
        if (backgroundColor) {
            this.setPadAttribute('backgroundColor', backgroundColor);
        }
        if (penColor) {
            this.setPadAttribute('penColor', penColor);
        }
        if (velocityFilterWeight) {
            this.setPadAttribute('velocityFilterWeight', velocityFilterWeight);
        }
        if (width || height) {
            const { width: previousWidth, height: previousHeight } = changes.options.previousValue;
            const data = this.smallPad.toDataURL();
            const image = new Image();
            image.src = data;
            image.onload = () => {
                this.initSmallPad();
                const ctx = this.smallCanvas.getContext('2d');
                ctx.drawImage(image, 0, 0, previousWidth, previousHeight, 0, 0, width, height);
            };
        }
        if (css) {
            if (this.bigCanvas) {
                for (const key in css) {
                    if (Object.prototype.hasOwnProperty.call(css, key)) {
                        const value = css[key];
                        this.renderer2.setStyle(this.bigCanvas, key, value);
                    }
                }
            }
            if (this.smallCanvas) {
                for (const key in css) {
                    if (Object.prototype.hasOwnProperty.call(css, key)) {
                        const value = css[key];
                        this.renderer2.setStyle(this.smallCanvas, key, value);
                    }
                }
            }
        }
    }
}
NgxSignaturePadComponent.decorators = [
    { type: Component, args: [{
                selector: 'ngx-signature-pad',
                template: "<canvas id=\"nsp-small\"></canvas>\n\n<ng-template #fullScreenTpl>\n  <div class=\"nsp-container\">\n    <div class=\"section left\" style=\"width: 100%;\" [ngStyle]=\"{'height': sectionHeight + 'px'}\"></div>\n    <canvas id=\"nsp-big\"></canvas>\n    <div class=\"section right\" style=\"width: 100%;\" [ngStyle]=\"{'height': sectionHeight + 'px'}\"></div>\n    <ng-content></ng-content>\n  </div>\n</ng-template>",
                styles: [".nsp-container{display:flex;flex-direction:column;position:fixed;left:0;top:0;width:100%;height:100vh;background:#fff}.nsp-container .section{flex:1}.nsp-container .section.left{border-bottom:2px dashed #dedee5}.nsp-container .section.right{border-top:2px dashed #dedee5}"]
            },] }
];
NgxSignaturePadComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: Overlay },
    { type: ViewContainerRef }
];
NgxSignaturePadComponent.propDecorators = {
    options: [{ type: Input }],
    beginSign: [{ type: Output }],
    endSign: [{ type: Output }],
    fullScreenTpl: [{ type: ViewChild, args: ['fullScreenTpl',] }]
};

class NgxSignaturePadModule {
}
NgxSignaturePadModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, OverlayModule],
                declarations: [NgxSignaturePadComponent],
                exports: [NgxSignaturePadComponent]
            },] }
];

/*
 * Public API Surface of ngx-signature-pad
 */

/**
 * Generated bundle index. Do not edit.
 */

export { NgxSignaturePadComponent, NgxSignaturePadModule };
//# sourceMappingURL=eve-sama-ngx-signature-pad.js.map
