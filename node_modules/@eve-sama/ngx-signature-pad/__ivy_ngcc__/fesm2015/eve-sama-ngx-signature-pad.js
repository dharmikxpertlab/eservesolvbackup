import { EventEmitter, Component, Renderer2, ViewContainerRef, Input, Output, ViewChild, NgModule } from '@angular/core';
import SignaturePad from 'signature_pad';
import { Overlay, OverlayModule } from '@angular/cdk/overlay';
import { TemplatePortal } from '@angular/cdk/portal';
import { CommonModule } from '@angular/common';

import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/cdk/overlay';
import * as ɵngcc2 from '@angular/common';

const _c0 = ["fullScreenTpl"];
const _c1 = function (a0) { return { "height": a0 }; };
function NgxSignaturePadComponent_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 2);
    ɵngcc0.ɵɵelement(1, "div", 3);
    ɵngcc0.ɵɵelement(2, "canvas", 4);
    ɵngcc0.ɵɵelement(3, "div", 5);
    ɵngcc0.ɵɵprojection(4);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngStyle", ɵngcc0.ɵɵpureFunction1(2, _c1, ctx_r1.sectionHeight + "px"));
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngStyle", ɵngcc0.ɵɵpureFunction1(4, _c1, ctx_r1.sectionHeight + "px"));
} }
const _c2 = ["*"];
class NgxSignaturePadComponent {
    constructor(renderer2, overlay, viewContainerRef) {
        this.renderer2 = renderer2;
        this.overlay = overlay;
        this.viewContainerRef = viewContainerRef;
        // #endregion
        this.signDataHistory = [];
        this._isEmpty = true;
        this.isFullScreen = false;
        this.options = {};
        this.beginSign = new EventEmitter();
        this.endSign = new EventEmitter();
    }
    get activePad() {
        return this.isFullScreen ? this.bigPad : this.smallPad;
    }
    fullScreen() {
        this.portal = new TemplatePortal(this.fullScreenTpl, this.viewContainerRef);
        this.overlayRef = this.overlay.create({
            positionStrategy: this.overlay.position().global(),
            scrollStrategy: this.overlay.scrollStrategies.block(),
            height: '100%',
            width: '100%'
        });
        this.overlayRef.attach(this.portal);
        this.initBigPad();
        // #region Copy miniScreen's content to fullScreen
        const { width: miniScreenWidth, height: miniScreenHeight } = this.options;
        const ctx = this.bigCanvas.getContext('2d');
        ctx.save();
        ctx.translate(this.fullScreenWidth, 0);
        ctx.rotate((90 * Math.PI) / 180);
        ctx.drawImage(this.smallCanvas, 0, 0, miniScreenWidth, miniScreenHeight, 0, 0, this.fullScreenHeight, this.fullScreenWidth);
        ctx.restore();
        // #endregion
        this.isFullScreen = true;
    }
    miniScreen() {
        this.smallPad.clear();
        // #region Copy fullScreen's content to miniScreen
        const { width: miniScreenWidth, height: miniScreenHeight } = this.options;
        const widthScale = miniScreenWidth / this.fullScreenHeight;
        const heightScale = miniScreenHeight / this.fullScreenWidth;
        const ctx = this.smallCanvas.getContext('2d');
        ctx.save();
        ctx.translate(0, miniScreenHeight);
        ctx.rotate((-90 * Math.PI) / 180);
        ctx.drawImage(this.bigCanvas, 0, 0, this.fullScreenWidth, this.fullScreenHeight, 0, 0, this.fullScreenWidth * widthScale, this.fullScreenHeight * heightScale);
        ctx.restore();
        // #endregion
        this.overlayRef.dispose();
        this.bigCanvas = null;
        this.bigPad = null;
        this.isFullScreen = false;
    }
    /** Returns signature image as an array of point groups */
    toData() {
        return this.activePad.toData();
    }
    /** Draws signature image from an array of point groups */
    fromData(pointGroups) {
        this.activePad.fromData(pointGroups);
    }
    toDataURL(type) {
        switch (type) {
            case 'image/jpeg':
                return this.activePad.toDataURL('image/jpeg');
            case 'image/svg+xml':
                return this.activePad.toDataURL('image/svg+xml');
            default:
                return this.activePad.toDataURL();
        }
    }
    revert() {
        this.signDataHistory.pop();
        this.fromData(this.signDataHistory);
        if (this.signDataHistory.length === 0) {
            this.setEmpty();
        }
    }
    // Clears the canvas
    clear() {
        this.setEmpty();
        this.signDataHistory = [];
        this.activePad.clear();
    }
    /** Return true if canvas is empty, otherwise return false */
    isEmpty() {
        return this._isEmpty;
    }
    /** Set canvas's state as dirty */
    setDirty() {
        this._isEmpty = false;
    }
    /** Set canvas's state as empty */
    setEmpty() {
        this._isEmpty = true;
    }
    getContext() {
        return this.isFullScreen ? this.bigCanvas.getContext('2d') : this.smallCanvas.getContext('2d');
    }
    initBigPad() {
        this.bigCanvas = document.querySelector('#nsp-big');
        const fullScreenOptions = JSON.parse(JSON.stringify(this.options));
        // Calculate the fullScreen pad's size
        this.fullScreenWidth = document.documentElement.clientWidth;
        const { width: miniScreenWidth, height: miniScreenHeight } = this.options;
        this.fullScreenHeight = (this.fullScreenWidth * miniScreenWidth) / miniScreenHeight;
        // Calculate section size
        const viewHeight = document.documentElement.clientHeight;
        const space = viewHeight - this.fullScreenHeight;
        this.sectionHeight = space / 2;
        // Init pad
        fullScreenOptions.width = this.fullScreenWidth;
        fullScreenOptions.height = this.fullScreenHeight;
        const { css } = fullScreenOptions;
        this.bigCanvas.width = this.fullScreenWidth;
        this.bigCanvas.height = this.fullScreenHeight;
        for (const key in css) {
            if (Object.prototype.hasOwnProperty.call(css, key)) {
                const value = css[key];
                this.renderer2.setStyle(this.bigCanvas, key, value);
            }
        }
        this.bigPad = new SignaturePad(this.bigCanvas, fullScreenOptions);
        this.bigPad.onBegin = this._onBegin.bind(this);
        this.bigPad.onEnd = this._onEnd.bind(this);
    }
    initSmallPad() {
        this.smallCanvas = document.querySelector('#nsp-small');
        const { width, height, css } = this.options;
        this.options.width = width ? width : 300;
        this.options.height = height ? height : 150;
        this.smallCanvas.width = this.options.width;
        this.smallCanvas.height = this.options.height;
        for (const key in css) {
            if (Object.prototype.hasOwnProperty.call(css, key)) {
                const value = css[key];
                this.renderer2.setStyle(this.smallCanvas, key, value);
            }
        }
        this.smallPad = new SignaturePad(this.smallCanvas, this.options);
        this.smallPad.onBegin = this._onBegin.bind(this);
        this.smallPad.onEnd = this._onEnd.bind(this);
    }
    _onBegin() {
        this.setDirty(); // When user draws, set state as dirty
        this.beginSign.emit();
    }
    _onEnd() {
        this.signDataHistory = this.toData();
        this.endSign.emit();
    }
    setPadAttribute(key, value) {
        if (this.bigPad) {
            this.bigPad[key] = value;
        }
        this.smallPad[key] = value;
    }
    ngOnInit() {
        this.initSmallPad();
    }
    ngOnChanges(changes) {
        if (changes.options.firstChange) {
            return;
        }
        const { dotSize, minWidth, maxWidth, throttle, minDistance, backgroundColor, penColor, velocityFilterWeight, width, height, css } = changes.options.currentValue;
        if (dotSize) {
            this.setPadAttribute('dotSize', dotSize);
        }
        if (minWidth) {
            this.setPadAttribute('minWidth', minWidth);
        }
        if (maxWidth) {
            this.setPadAttribute('maxWidth', maxWidth);
        }
        if (throttle) {
            this.setPadAttribute('throttle', throttle);
        }
        if (minDistance) {
            this.setPadAttribute('minDistance', minDistance);
        }
        if (backgroundColor) {
            this.setPadAttribute('backgroundColor', backgroundColor);
        }
        if (penColor) {
            this.setPadAttribute('penColor', penColor);
        }
        if (velocityFilterWeight) {
            this.setPadAttribute('velocityFilterWeight', velocityFilterWeight);
        }
        if (width || height) {
            const { width: previousWidth, height: previousHeight } = changes.options.previousValue;
            const data = this.smallPad.toDataURL();
            const image = new Image();
            image.src = data;
            image.onload = () => {
                this.initSmallPad();
                const ctx = this.smallCanvas.getContext('2d');
                ctx.drawImage(image, 0, 0, previousWidth, previousHeight, 0, 0, width, height);
            };
        }
        if (css) {
            if (this.bigCanvas) {
                for (const key in css) {
                    if (Object.prototype.hasOwnProperty.call(css, key)) {
                        const value = css[key];
                        this.renderer2.setStyle(this.bigCanvas, key, value);
                    }
                }
            }
            if (this.smallCanvas) {
                for (const key in css) {
                    if (Object.prototype.hasOwnProperty.call(css, key)) {
                        const value = css[key];
                        this.renderer2.setStyle(this.smallCanvas, key, value);
                    }
                }
            }
        }
    }
}
NgxSignaturePadComponent.ɵfac = function NgxSignaturePadComponent_Factory(t) { return new (t || NgxSignaturePadComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.Overlay), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef)); };
NgxSignaturePadComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NgxSignaturePadComponent, selectors: [["ngx-signature-pad"]], viewQuery: function NgxSignaturePadComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c0, 1);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.fullScreenTpl = _t.first);
    } }, inputs: { options: "options" }, outputs: { beginSign: "beginSign", endSign: "endSign" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c2, decls: 3, vars: 0, consts: [["id", "nsp-small"], ["fullScreenTpl", ""], [1, "nsp-container"], [1, "section", "left", 2, "width", "100%", 3, "ngStyle"], ["id", "nsp-big"], [1, "section", "right", 2, "width", "100%", 3, "ngStyle"]], template: function NgxSignaturePadComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelement(0, "canvas", 0);
        ɵngcc0.ɵɵtemplate(1, NgxSignaturePadComponent_ng_template_1_Template, 5, 6, "ng-template", null, 1, ɵngcc0.ɵɵtemplateRefExtractor);
    } }, directives: [ɵngcc2.NgStyle], styles: [".nsp-container[_ngcontent-%COMP%]{display:flex;flex-direction:column;position:fixed;left:0;top:0;width:100%;height:100vh;background:#fff}.nsp-container[_ngcontent-%COMP%]   .section[_ngcontent-%COMP%]{flex:1}.nsp-container[_ngcontent-%COMP%]   .section.left[_ngcontent-%COMP%]{border-bottom:2px dashed #dedee5}.nsp-container[_ngcontent-%COMP%]   .section.right[_ngcontent-%COMP%]{border-top:2px dashed #dedee5}"] });
NgxSignaturePadComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: Overlay },
    { type: ViewContainerRef }
];
NgxSignaturePadComponent.propDecorators = {
    options: [{ type: Input }],
    beginSign: [{ type: Output }],
    endSign: [{ type: Output }],
    fullScreenTpl: [{ type: ViewChild, args: ['fullScreenTpl',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxSignaturePadComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-signature-pad',
                template: "<canvas id=\"nsp-small\"></canvas>\n\n<ng-template #fullScreenTpl>\n  <div class=\"nsp-container\">\n    <div class=\"section left\" style=\"width: 100%;\" [ngStyle]=\"{'height': sectionHeight + 'px'}\"></div>\n    <canvas id=\"nsp-big\"></canvas>\n    <div class=\"section right\" style=\"width: 100%;\" [ngStyle]=\"{'height': sectionHeight + 'px'}\"></div>\n    <ng-content></ng-content>\n  </div>\n</ng-template>",
                styles: [".nsp-container{display:flex;flex-direction:column;position:fixed;left:0;top:0;width:100%;height:100vh;background:#fff}.nsp-container .section{flex:1}.nsp-container .section.left{border-bottom:2px dashed #dedee5}.nsp-container .section.right{border-top:2px dashed #dedee5}"]
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: ɵngcc1.Overlay }, { type: ɵngcc0.ViewContainerRef }]; }, { options: [{
            type: Input
        }], beginSign: [{
            type: Output
        }], endSign: [{
            type: Output
        }], fullScreenTpl: [{
            type: ViewChild,
            args: ['fullScreenTpl']
        }] }); })();

class NgxSignaturePadModule {
}
NgxSignaturePadModule.ɵfac = function NgxSignaturePadModule_Factory(t) { return new (t || NgxSignaturePadModule)(); };
NgxSignaturePadModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NgxSignaturePadModule });
NgxSignaturePadModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule, OverlayModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NgxSignaturePadModule, { declarations: function () { return [NgxSignaturePadComponent]; }, imports: function () { return [CommonModule, OverlayModule]; }, exports: function () { return [NgxSignaturePadComponent]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxSignaturePadModule, [{
        type: NgModule,
        args: [{
                imports: [CommonModule, OverlayModule],
                declarations: [NgxSignaturePadComponent],
                exports: [NgxSignaturePadComponent]
            }]
    }], null, null); })();

/*
 * Public API Surface of ngx-signature-pad
 */

/**
 * Generated bundle index. Do not edit.
 */

export { NgxSignaturePadComponent, NgxSignaturePadModule };

//# sourceMappingURL=eve-sama-ngx-signature-pad.js.map