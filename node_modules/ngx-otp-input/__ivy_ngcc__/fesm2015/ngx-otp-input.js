import { EventEmitter, Component, ChangeDetectionStrategy, Input, Output, ViewChildren, HostListener, Directive, NgModule } from '@angular/core';
import { FormArray, FormControl, Validators, ReactiveFormsModule, FormsModule } from '@angular/forms';
import { CommonModule } from '@angular/common';

import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/forms';
import * as ɵngcc2 from '@angular/common';

const _c0 = ["otpInputElement"];
function NgxOtpInputComponent_div_1_Template(rf, ctx) { if (rf & 1) {
    const _r5 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 2);
    ɵngcc0.ɵɵelementStart(1, "label");
    ɵngcc0.ɵɵelementStart(2, "input", 3, 4);
    ɵngcc0.ɵɵlistener("focus", function NgxOtpInputComponent_div_1_Template_input_focus_2_listener() { ɵngcc0.ɵɵrestoreView(_r5); const i_r2 = ctx.index; const ctx_r4 = ɵngcc0.ɵɵnextContext(); return ctx_r4.handleFocus(i_r2); })("keyup", function NgxOtpInputComponent_div_1_Template_input_keyup_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r5); const i_r2 = ctx.index; const ctx_r6 = ɵngcc0.ɵɵnextContext(); return ctx_r6.handleKeyup($event.key, i_r2); })("keyup.arrowLeft", function NgxOtpInputComponent_div_1_Template_input_keyup_arrowLeft_2_listener() { ɵngcc0.ɵɵrestoreView(_r5); const i_r2 = ctx.index; const ctx_r7 = ɵngcc0.ɵɵnextContext(); return ctx_r7.handleLeftArrow(i_r2); })("keyup.arrowRight", function NgxOtpInputComponent_div_1_Template_input_keyup_arrowRight_2_listener() { ɵngcc0.ɵɵrestoreView(_r5); const i_r2 = ctx.index; const ctx_r8 = ɵngcc0.ɵɵnextContext(); return ctx_r8.handleRightArrow(i_r2); })("keydown.backspace", function NgxOtpInputComponent_div_1_Template_input_keydown_backspace_2_listener() { ɵngcc0.ɵɵrestoreView(_r5); const i_r2 = ctx.index; const ctx_r9 = ɵngcc0.ɵɵnextContext(); return ctx_r9.handleKeydown(i_r2); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const control_r1 = ctx.$implicit;
    const i_r2 = ctx.index;
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ctx_r0.config.classList == null ? null : ctx_r0.config.classList.inputBox);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵattribute("aria-label", ctx_r0.getAriaLabelByIndex(i_r2));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("id", "ngx-otp-input-" + i_r2)("formControl", control_r1)("ngxOtpPattern", ctx_r0.pattern)("type", ctx_r0.config.isPasswordInput ? "password" : "text")("ngClass", ctx_r0.classList[i_r2]);
} }
class NgxOtpInputComponent {
    constructor() {
        this.ngxOtpArray = new FormArray([]);
        this.focusedInputHasValue = false;
        this.lastFocus = 0;
        this.defaultAriaLabel = 'One time password input';
        this.ariaLabels = [];
        this.classList = [];
        this.disable = false;
        this.otpChange = new EventEmitter();
        this.fill = new EventEmitter();
    }
    get ngxOtpArrayControls() {
        return this.ngxOtpArray.controls;
    }
    set status(status) {
        this.ngxOtpStatus = status;
        this.setInputClasses();
    }
    onPaste(event) {
        event.preventDefault();
        this.setValue(event.clipboardData.getData('text'));
    }
    ngOnInit() {
        this.setUpOtpForm();
        this.setUpAriaLabels();
        this.setInputClasses();
        this.otpFormChangeListener();
        this.handleDisable(this.disable);
        if (this.config.autoblur === undefined) {
            this.config.autoblur = true;
        }
    }
    ngAfterViewInit() {
        if (this.config.numericInputMode || !this.config.pattern) {
            this.otpInputElements.map((element) => {
                element.nativeElement.setAttribute('inputmode', 'numeric');
                element.nativeElement.setAttribute('pattern', '[0-9]*');
            });
        }
        if (this.config.autofocus) {
            this.setFocus(0);
        }
    }
    ngOnChanges(changes) {
        if (changes.hasOwnProperty('disable')) {
            this.handleDisable(this.disable);
        }
    }
    ngOnDestroy() {
        this.ngxOtpArray$.unsubscribe();
    }
    getAriaLabelByIndex(index) {
        return this.ariaLabels[index]
            ? this.ariaLabels[index]
            : this.defaultAriaLabel;
    }
    handleFocus(index) {
        this.lastFocus = index;
        this.getInputElementByIndex(index).select();
    }
    handleKeyup(value, index) {
        if (this.pattern.test(value) && value !== 'Backspace') {
            this.getFormControlByIndex(index).setValue(value); // prevent fast type errors
            this.stepForward(index);
        }
        else if (value === 'Backspace') {
            this.stepBackward(index);
        }
        this.setInputClasses();
    }
    handleKeydown(index) {
        this.focusedInputHasValue = !!this.getFormControlByIndex(index).value;
    }
    handleLeftArrow(index) {
        if (index > 0) {
            this.setFocus(index - 1);
        }
    }
    handleRightArrow(index) {
        if (index < this.config.otpLength - 1) {
            this.setFocus(index + 1);
        }
    }
    clear() {
        this.ngxOtpArray.reset();
        this.setInputClasses();
    }
    setUpOtpForm() {
        for (let i = 0; i < this.config.otpLength; i++) {
            this.ngxOtpArray.push(new FormControl(null, [Validators.required]));
        }
        this.pattern = this.config.pattern || /^\d+$/;
    }
    setUpAriaLabels() {
        if (this.config.ariaLabels) {
            Array.isArray(this.config.ariaLabels)
                ? (this.ariaLabels = this.config.ariaLabels)
                : (this.ariaLabels = new Array(this.config.otpLength).fill(this.config.ariaLabels));
        }
    }
    setInputClasses() {
        var _a, _b;
        const inputEntry = [];
        const classList = this.config.classList;
        for (let i = 0; i < this.config.otpLength; i++) {
            const isFilled = this.isInputFilled(i)
                ? ((_a = this.config.classList) === null || _a === void 0 ? void 0 : _a.inputFilled) || ''
                : '';
            const isDisabled = this.disable
                ? ((_b = this.config.classList) === null || _b === void 0 ? void 0 : _b.inputDisabled) || 'ngx-otp-input-disabled'
                : '';
            let status = '';
            if (this.ngxOtpStatus === 'success') {
                status = this.config.classList.inputSuccess;
            }
            else if (this.ngxOtpStatus === 'error') {
                status = this.config.classList.inputError;
            }
            inputEntry[i] = [(classList === null || classList === void 0 ? void 0 : classList.input) || '', isFilled, isDisabled, status];
        }
        this.classList = inputEntry;
    }
    setValue(value) {
        if (this.pattern.test(value)) {
            let lastIndex = 0;
            value
                .split('')
                .slice(0, this.config.otpLength)
                .map((character, index) => {
                this.getFormControlByIndex(index).setValue(character);
                lastIndex = index;
            });
            this.setInputClasses();
            this.setFocusAfterValueSet(lastIndex);
        }
    }
    handleDisable(disable) {
        var _a, _b;
        disable ? (_a = this.ngxOtpArray) === null || _a === void 0 ? void 0 : _a.disable() : (_b = this.ngxOtpArray) === null || _b === void 0 ? void 0 : _b.enable();
        this.setInputClasses();
    }
    stepForward(index) {
        if (this.ngxOtpArray.valid && this.config.autoblur) {
            this.removeFocus(index);
        }
        else if (index < this.config.otpLength - 1) {
            this.setFocus(index + 1);
        }
    }
    stepBackward(index) {
        if (!this.focusedInputHasValue && index > 0) {
            this.setFocus(index - 1);
        }
    }
    setFocusAfterValueSet(lastIndex) {
        if (lastIndex < this.config.otpLength - 1) {
            this.setFocus(lastIndex + 1);
        }
        else {
            this.removeFocus(this.lastFocus);
        }
    }
    setFocus(index) {
        this.getInputElementByIndex(index).focus();
    }
    removeFocus(index) {
        this.getInputElementByIndex(index).blur();
    }
    isInputFilled(index) {
        var _a;
        return (_a = this.getFormControlByIndex(index)) === null || _a === void 0 ? void 0 : _a.valid;
    }
    getInputElementByIndex(index) {
        return this.otpInputElements.toArray()[index].nativeElement;
    }
    getFormControlByIndex(index) {
        return this.ngxOtpArray.controls[index];
    }
    otpFormChangeListener() {
        this.ngxOtpArray$ = this.ngxOtpArray.valueChanges.subscribe((values) => {
            this.otpChange.emit(values);
            if (this.ngxOtpArray.valid) {
                this.fill.emit(values.join(''));
            }
        });
    }
}
NgxOtpInputComponent.ɵfac = function NgxOtpInputComponent_Factory(t) { return new (t || NgxOtpInputComponent)(); };
NgxOtpInputComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NgxOtpInputComponent, selectors: [["ngx-otp-input"]], viewQuery: function NgxOtpInputComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c0, 1);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.otpInputElements = _t);
    } }, hostBindings: function NgxOtpInputComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("paste", function NgxOtpInputComponent_paste_HostBindingHandler($event) { return ctx.onPaste($event); });
    } }, inputs: { disable: "disable", status: "status", config: "config" }, outputs: { otpChange: "otpChange", fill: "fill" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 2, vars: 2, consts: [[1, "ngx-otp-input-container", 3, "ngClass"], ["class", "ngx-otp-input-box", 3, "ngClass", 4, "ngFor", "ngForOf"], [1, "ngx-otp-input-box", 3, "ngClass"], ["maxlength", "1", "autocomplete", "off", "autocapitalize", "off", "spellcheck", "false", 1, "ngx-otp-input", 3, "id", "formControl", "ngxOtpPattern", "type", "ngClass", "focus", "keyup", "keyup.arrowLeft", "keyup.arrowRight", "keydown.backspace"], ["otpInputElement", ""]], template: function NgxOtpInputComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "form", 0);
        ɵngcc0.ɵɵtemplate(1, NgxOtpInputComponent_div_1_Template, 4, 7, "div", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngClass", ctx.config.classList == null ? null : ctx.config.classList.container);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.ngxOtpArrayControls);
    } }, directives: function () { return [ɵngcc1.ɵangular_packages_forms_forms_ba, ɵngcc1.NgControlStatusGroup, ɵngcc1.NgForm, ɵngcc2.NgClass, ɵngcc2.NgForOf, ɵngcc1.DefaultValueAccessor, ɵngcc1.MaxLengthValidator, ɵngcc1.NgControlStatus, ɵngcc1.FormControlDirective, PatternDirective]; }, styles: [".ngx-otp-input-container[_ngcontent-%COMP%]{display:flex}.ngx-otp-input-box[_ngcontent-%COMP%]{margin:0 5px}.ngx-otp-input-box[_ngcontent-%COMP%]:first-child{margin-left:0}.ngx-otp-input-box[_ngcontent-%COMP%]:last-child{margin-right:0}.ngx-otp-input[_ngcontent-%COMP%]{width:35px;height:35px;text-align:center;font-size:1.25rem;border:1px solid #212121;border-radius:4px;outline:0}.ngx-otp-input-disabled[_ngcontent-%COMP%]{opacity:.3}"], changeDetection: 0 });
NgxOtpInputComponent.propDecorators = {
    config: [{ type: Input }],
    disable: [{ type: Input }],
    status: [{ type: Input }],
    otpChange: [{ type: Output }],
    fill: [{ type: Output }],
    otpInputElements: [{ type: ViewChildren, args: ['otpInputElement',] }],
    onPaste: [{ type: HostListener, args: ['paste', ['$event'],] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxOtpInputComponent, [{
        type: Component,
        args: [{
                // tslint:disable-next-line:component-selector
                selector: 'ngx-otp-input',
                template: "<form [ngClass]=\"config.classList?.container\" class=\"ngx-otp-input-container\">\n  <div\n    *ngFor=\"let control of ngxOtpArrayControls; let i = index\"\n    [ngClass]=\"config.classList?.inputBox\"\n    class=\"ngx-otp-input-box\"\n  >\n    <label [attr.aria-label]=\"getAriaLabelByIndex(i)\">\n      <input\n        #otpInputElement\n        [id]=\"'ngx-otp-input-' + i\"\n        [formControl]=\"control\"\n        [ngxOtpPattern]=\"pattern\"\n        [type]=\"config.isPasswordInput ? 'password' : 'text'\"\n        [ngClass]=\"classList[i]\"\n        (focus)=\"handleFocus(i)\"\n        (keyup)=\"handleKeyup($event.key, i)\"\n        (keyup.arrowLeft)=\"handleLeftArrow(i)\"\n        (keyup.arrowRight)=\"handleRightArrow(i)\"\n        (keydown.backspace)=\"handleKeydown(i)\"\n        class=\"ngx-otp-input\"\n        maxlength=\"1\"\n        autocomplete=\"off\"\n        autocapitalize=\"off\"\n        spellcheck=\"false\"\n      />\n    </label>\n  </div>\n</form>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [".ngx-otp-input-container{display:flex}.ngx-otp-input-box{margin:0 5px}.ngx-otp-input-box:first-child{margin-left:0}.ngx-otp-input-box:last-child{margin-right:0}.ngx-otp-input{width:35px;height:35px;text-align:center;font-size:1.25rem;border:1px solid #212121;border-radius:4px;outline:0}.ngx-otp-input-disabled{opacity:.3}"]
            }]
    }], function () { return []; }, { disable: [{
            type: Input
        }], otpChange: [{
            type: Output
        }], fill: [{
            type: Output
        }], status: [{
            type: Input
        }], onPaste: [{
            type: HostListener,
            args: ['paste', ['$event']]
        }], config: [{
            type: Input
        }], otpInputElements: [{
            type: ViewChildren,
            args: ['otpInputElement']
        }] }); })();

class PatternDirective {
    constructor() {
        // allowed keys apart from numeric characters
        this.allowedKeys = [
            'Backspace',
            'ArrowLeft',
            'ArrowRight',
            'Escape',
            'Tab',
        ];
    }
    onKeyDown(e) {
        if (this.allowedKeys.includes(e.key) ||
            (e.key === 'a' && e.ctrlKey === true) || // Allow: Ctrl+A
            (e.key === 'c' && e.ctrlKey === true) || // Allow: Ctrl+C
            (e.key === 'v' && e.ctrlKey === true) || // Allow: Ctrl+V
            (e.key === 'x' && e.ctrlKey === true) || // Allow: Ctrl+X
            (e.key === 'a' && e.metaKey === true) || // Cmd+A (Mac)
            (e.key === 'c' && e.metaKey === true) || // Cmd+C (Mac)
            (e.key === 'v' && e.metaKey === true) || // Cmd+V (Mac)
            (e.key === 'x' && e.metaKey === true) // Cmd+X (Mac)
        ) {
            return; // let it happen, don't do anything
        }
        else if (!this.pattern.test(e.key)) {
            e.preventDefault();
        }
    }
}
PatternDirective.ɵfac = function PatternDirective_Factory(t) { return new (t || PatternDirective)(); };
PatternDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: PatternDirective, selectors: [["", "ngxOtpPattern", ""]], hostBindings: function PatternDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keydown", function PatternDirective_keydown_HostBindingHandler($event) { return ctx.onKeyDown($event); });
    } }, inputs: { pattern: ["ngxOtpPattern", "pattern"] } });
PatternDirective.propDecorators = {
    pattern: [{ type: Input, args: ['ngxOtpPattern',] }],
    onKeyDown: [{ type: HostListener, args: ['keydown', ['$event'],] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(PatternDirective, [{
        type: Directive,
        args: [{
                // tslint:disable-next-line:directive-selector
                selector: '[ngxOtpPattern]'
            }]
    }], function () { return []; }, { onKeyDown: [{
            type: HostListener,
            args: ['keydown', ['$event']]
        }], pattern: [{
            type: Input,
            args: ['ngxOtpPattern']
        }] }); })();

class NgxOtpInputModule {
}
NgxOtpInputModule.ɵfac = function NgxOtpInputModule_Factory(t) { return new (t || NgxOtpInputModule)(); };
NgxOtpInputModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NgxOtpInputModule });
NgxOtpInputModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[ReactiveFormsModule, FormsModule, CommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NgxOtpInputModule, { declarations: function () { return [NgxOtpInputComponent, PatternDirective]; }, imports: function () { return [ReactiveFormsModule, FormsModule, CommonModule]; }, exports: function () { return [NgxOtpInputComponent]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxOtpInputModule, [{
        type: NgModule,
        args: [{
                declarations: [NgxOtpInputComponent, PatternDirective],
                imports: [ReactiveFormsModule, FormsModule, CommonModule],
                exports: [NgxOtpInputComponent]
            }]
    }], null, null); })();

/*
 * Public API Surface of ngx-otp-input
 */

/**
 * Generated bundle index. Do not edit.
 */

export { NgxOtpInputComponent, NgxOtpInputModule, PatternDirective as ɵa };

//# sourceMappingURL=ngx-otp-input.js.map